#include "cFileLoader_Imp.h"

//#include <iostream>

#include <assimp/Importer.hpp>      // C++ importer interface
#include <assimp/scene.h>           // Output data structure
#include <assimp/postprocess.h>     // Post processing flags

// Note: Depending on the library, you have to use the specific config.h
// file from the lib folder. This is generated by CMake.
// This config is VS22vc143x64static

#include <sstream>

bool cFileLoader_Imp::Load3DModelFile(std::string filename, AH::cFileLoader::sPostProcessFlags postProcessOptions)
{
    std::string filename_and_path = filename;

    if (this->m_basePath_no_end_slash != "")
    {
        filename_and_path = this->m_basePath_no_end_slash + '/' + filename;
    }

    // Translate the boolean helper flags to the assimp post processing flags
    unsigned int assimpPostProcessingFlags = this->m_loadAssimpPostProcessingFlags(postProcessOptions);

    // This is from the assimp help documentation
    // Create an instance of the Importer class
//    Assimp::Importer importer;
    // And have it read the given file with some example postprocessing
    // Usually - if speed is not the most important aspect for you - you'll 
    // probably to request more postprocessing than we do in this example.
    const aiScene* pOGScene = this->m_AssimpImporter.ReadFile(filename_and_path.c_str(), assimpPostProcessingFlags);


//    const aiScene* scene = importer.ReadFile(filename_and_path.c_str(),
//                                             aiProcess_CalcTangentSpace |
//                                             aiProcess_Triangulate |
//                                             aiProcess_JoinIdenticalVertices |
//                                             aiProcess_SortByPType);
    // aiProcess_CalcTangentSpace:      Calculates the tangents and bitangents for the imported meshes.
    // aiProcess_Triangulate:           Triangulates all faces of all meshes.
    // aiProcess_JoinIdenticalVertices: Identifies and joins identical vertex data sets within all imported meshes.
    // aiProcess_SortByPType:           This step splits meshes with more than one primitive type in homogeneous sub-meshes.,
    // aiProcess_GenNormals:            Generates normals for all faces of all meshes.
    //                                  (is ignored if normals are already there at the time this flag is evaluated.)
    //                                  (can *NOT* be used with aiProcess_GenSmoothNormals)
    // aiProcess_GenSmoothNormals:      Generates smooth normals for all vertices in the mesh.
    //                                  (...is ignored if normals are already there at the time this flag is evaluated.)
    //                                  (can *NOT* be used with aiProcess_GenNormals)
    // aiProcess_FixInfacingNormals:    This step tries to determine which meshes have normal vectors that are facing inwards and inverts them.
    // If the import failed, report it


    if (!pOGScene)
    {
        std::string errorString(this->m_AssimpImporter.GetErrorString());
        this->m_AppendErrorString(errorString);
        return false;
    }
    // Now we can access the file's contents. 



    AH::cScene* pTheScene = new AH::cScene();
    pTheScene->scene_flags.DecodeSceneFlags(pOGScene->mFlags);

    // Any meshes? 
    for ( unsigned int meshIndex = 0; meshIndex != pOGScene->mNumMeshes; meshIndex++ )
    {
        AH::cMesh* pCurMesh = new AH::cMesh();

        pCurMesh->name.append(pOGScene->mMeshes[meshIndex]->mName.C_Str());

        // Add an empty vector for each colour channel...
        unsigned int numColourChannels = pOGScene->mMeshes[meshIndex]->GetNumColorChannels();
        for (unsigned int count = 0; count != numColourChannels; count++)
        {
            pCurMesh->vecColourSetsRGBA.push_back(std::vector<glm::vec4>());
        }

        // Add an empty vector for each texture coordinate channel...
        unsigned int numTextureChannels = pOGScene->mMeshes[meshIndex]->GetNumUVChannels();
        for (unsigned int textureChannelIndex = 0; textureChannelIndex != numTextureChannels; textureChannelIndex++)
        {
            AH::cMesh::sUVChannel textureChannel;
            if (pOGScene->mMeshes[meshIndex]->mTextureCoordsNames != nullptr)
            {
                textureChannel.name.append(pOGScene->mMeshes[meshIndex]->GetTextureCoordsName(textureChannelIndex)->C_Str());
            }
            pCurMesh->vecTextureChannels.push_back(textureChannel);
        }


        for (unsigned int vertIndex = 0; vertIndex != pOGScene->mMeshes[meshIndex]->mNumVertices; vertIndex++ )
        {
            if ( pOGScene->mMeshes[meshIndex]->HasPositions() )
            {
                aiVector3D curPosition = pOGScene->mMeshes[meshIndex]->mVertices[vertIndex];
                pCurMesh->vecPositions.push_back(glm::vec3(curPosition.x, curPosition.y, curPosition.z));
            }

            if (pOGScene->mMeshes[meshIndex]->HasNormals())
            {
                aiVector3D curNormal = pOGScene->mMeshes[meshIndex]->mNormals[vertIndex];
                pCurMesh->vecNormals.push_back(glm::vec3(curNormal.x, curNormal.y, curNormal.z));
            }

            if (pOGScene->mMeshes[meshIndex]->HasTangentsAndBitangents() )
            {
                aiVector3D curTangent = pOGScene->mMeshes[meshIndex]->mTangents[vertIndex];
                pCurMesh->vecTangents.push_back(glm::vec3(curTangent.x, curTangent.y, curTangent.z));

                aiVector3D curBiTangent = pOGScene->mMeshes[meshIndex]->mBitangents[vertIndex];
                pCurMesh->vecBiTangents.push_back(glm::vec3(curBiTangent.x, curBiTangent.y, curBiTangent.z));
            }

            unsigned int numColourChannels = pOGScene->mMeshes[meshIndex]->GetNumColorChannels();
            for ( unsigned int colourChannelIndex = 0; colourChannelIndex != numColourChannels; colourChannelIndex++ )
            {
                if (pOGScene->mMeshes[meshIndex]->HasVertexColors(colourChannelIndex) )
                {
                    aiColor4D curColour = pOGScene->mMeshes[meshIndex]->mColors[colourChannelIndex][vertIndex];
                    // std::vector< std::vector<glm::vec4> > vecColourSetsRGBA;
                    pCurMesh->vecColourSetsRGBA[numColourChannels].push_back( glm::vec4(curColour.r, curColour.g, curColour.b, curColour.a) );
                }
            }//for ( unsigned int colourChannelIndex
            
            unsigned int numTextureChannels = pOGScene->mMeshes[meshIndex]->GetNumUVChannels();
            for (unsigned int textureChannelIndex = 0; textureChannelIndex != numTextureChannels; textureChannelIndex++)
            {
                if (pOGScene->mMeshes[meshIndex]->HasTextureCoords(textureChannelIndex))
                {
                    aiVector3D curUV = pOGScene->mMeshes[meshIndex]->mTextureCoords[textureChannelIndex][vertIndex];
                    // std::vector< std::vector<glm::vec4> > vecColourSetsRGBA;
                    pCurMesh->vecTextureChannels[textureChannelIndex].vecUVs.push_back(glm::vec3(curUV.x, curUV.y, curUV.z));
                }
            }//for ( unsigned int textureChannelIndex


        }//for (unsigned int vertIndex


        // The indices
        unsigned int numFaces = pOGScene->mMeshes[meshIndex]->mNumFaces;
        for ( unsigned int faceIndex = 0; faceIndex != numFaces; faceIndex++ )
        {
            AH::cFace newFace;
            unsigned int numIndicesThisFace = pOGScene->mMeshes[meshIndex]->mFaces[faceIndex].mNumIndices;

            switch (pOGScene->mMeshes[meshIndex]->mFaces[faceIndex].mNumIndices)
            {
            case 1:
                pCurMesh->numPoints++;
                break;
            case 2:
                pCurMesh->numLines++;
                break;
            case 3:
                pCurMesh->numTriangles++;
                break;
            case 4:
                pCurMesh->numQuads++;
                break;
            default:
                pCurMesh->numNGons++;
            }// switch (pOGScene->mMeshes...mNumIndices           
                
            for (unsigned int indexIndex = 0; indexIndex != numIndicesThisFace; indexIndex++)
            {


                unsigned int indexValue = pOGScene->mMeshes[meshIndex]->mFaces[faceIndex].mIndices[indexIndex];

                newFace.vecIndices.push_back(indexValue);
                //
                pCurMesh->vecIndices.push_back(indexValue);
            }
            pCurMesh->vecFaces.push_back(newFace);
        }// for ( unsigned int faceIndex

 //       pOGScene->mMeshes[meshIndex]->mFaces[0].


        pTheScene->vecMeshes.push_back(pCurMesh);

    }//for ( unsigned int meshIndex








    this->map_Scenes_by_filename[filename] = pTheScene;

    //    DoTheSceneProcessing(scene);
    // We're done. Everything will be cleaned up by the importer destructor
    return true;
}